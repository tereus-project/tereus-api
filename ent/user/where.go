// Code generated by entc, DO NOT EDIT.

package user

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/tereus-project/tereus-api/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// Password applies equality check predicate on the "password" field. It's identical to PasswordEQ.
func Password(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPassword), v))
	})
}

// GithubUserID applies equality check predicate on the "github_user_id" field. It's identical to GithubUserIDEQ.
func GithubUserID(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGithubUserID), v))
	})
}

// GithubAccessToken applies equality check predicate on the "github_access_token" field. It's identical to GithubAccessTokenEQ.
func GithubAccessToken(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGithubAccessToken), v))
	})
}

// GitlabUserID applies equality check predicate on the "gitlab_user_id" field. It's identical to GitlabUserIDEQ.
func GitlabUserID(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabUserID), v))
	})
}

// GitlabAccessToken applies equality check predicate on the "gitlab_access_token" field. It's identical to GitlabAccessTokenEQ.
func GitlabAccessToken(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabRefreshToken applies equality check predicate on the "gitlab_refresh_token" field. It's identical to GitlabRefreshTokenEQ.
func GitlabRefreshToken(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabAccessTokenExpiresAt applies equality check predicate on the "gitlab_access_token_expires_at" field. It's identical to GitlabAccessTokenExpiresAtEQ.
func GitlabAccessTokenExpiresAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEmail), v))
	})
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEmail), v...))
	})
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEmail), v...))
	})
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEmail), v))
	})
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEmail), v))
	})
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEmail), v))
	})
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEmail), v))
	})
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEmail), v))
	})
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEmail), v))
	})
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEmail), v))
	})
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEmail), v))
	})
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEmail), v))
	})
}

// PasswordEQ applies the EQ predicate on the "password" field.
func PasswordEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPassword), v))
	})
}

// PasswordNEQ applies the NEQ predicate on the "password" field.
func PasswordNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPassword), v))
	})
}

// PasswordIn applies the In predicate on the "password" field.
func PasswordIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPassword), v...))
	})
}

// PasswordNotIn applies the NotIn predicate on the "password" field.
func PasswordNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPassword), v...))
	})
}

// PasswordGT applies the GT predicate on the "password" field.
func PasswordGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPassword), v))
	})
}

// PasswordGTE applies the GTE predicate on the "password" field.
func PasswordGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPassword), v))
	})
}

// PasswordLT applies the LT predicate on the "password" field.
func PasswordLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPassword), v))
	})
}

// PasswordLTE applies the LTE predicate on the "password" field.
func PasswordLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPassword), v))
	})
}

// PasswordContains applies the Contains predicate on the "password" field.
func PasswordContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPassword), v))
	})
}

// PasswordHasPrefix applies the HasPrefix predicate on the "password" field.
func PasswordHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPassword), v))
	})
}

// PasswordHasSuffix applies the HasSuffix predicate on the "password" field.
func PasswordHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPassword), v))
	})
}

// PasswordIsNil applies the IsNil predicate on the "password" field.
func PasswordIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPassword)))
	})
}

// PasswordNotNil applies the NotNil predicate on the "password" field.
func PasswordNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPassword)))
	})
}

// PasswordEqualFold applies the EqualFold predicate on the "password" field.
func PasswordEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPassword), v))
	})
}

// PasswordContainsFold applies the ContainsFold predicate on the "password" field.
func PasswordContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPassword), v))
	})
}

// GithubUserIDEQ applies the EQ predicate on the "github_user_id" field.
func GithubUserIDEQ(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDNEQ applies the NEQ predicate on the "github_user_id" field.
func GithubUserIDNEQ(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDIn applies the In predicate on the "github_user_id" field.
func GithubUserIDIn(vs ...int64) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGithubUserID), v...))
	})
}

// GithubUserIDNotIn applies the NotIn predicate on the "github_user_id" field.
func GithubUserIDNotIn(vs ...int64) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGithubUserID), v...))
	})
}

// GithubUserIDGT applies the GT predicate on the "github_user_id" field.
func GithubUserIDGT(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDGTE applies the GTE predicate on the "github_user_id" field.
func GithubUserIDGTE(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDLT applies the LT predicate on the "github_user_id" field.
func GithubUserIDLT(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDLTE applies the LTE predicate on the "github_user_id" field.
func GithubUserIDLTE(v int64) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGithubUserID), v))
	})
}

// GithubUserIDIsNil applies the IsNil predicate on the "github_user_id" field.
func GithubUserIDIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGithubUserID)))
	})
}

// GithubUserIDNotNil applies the NotNil predicate on the "github_user_id" field.
func GithubUserIDNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGithubUserID)))
	})
}

// GithubAccessTokenEQ applies the EQ predicate on the "github_access_token" field.
func GithubAccessTokenEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenNEQ applies the NEQ predicate on the "github_access_token" field.
func GithubAccessTokenNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenIn applies the In predicate on the "github_access_token" field.
func GithubAccessTokenIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGithubAccessToken), v...))
	})
}

// GithubAccessTokenNotIn applies the NotIn predicate on the "github_access_token" field.
func GithubAccessTokenNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGithubAccessToken), v...))
	})
}

// GithubAccessTokenGT applies the GT predicate on the "github_access_token" field.
func GithubAccessTokenGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenGTE applies the GTE predicate on the "github_access_token" field.
func GithubAccessTokenGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenLT applies the LT predicate on the "github_access_token" field.
func GithubAccessTokenLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenLTE applies the LTE predicate on the "github_access_token" field.
func GithubAccessTokenLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenContains applies the Contains predicate on the "github_access_token" field.
func GithubAccessTokenContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenHasPrefix applies the HasPrefix predicate on the "github_access_token" field.
func GithubAccessTokenHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenHasSuffix applies the HasSuffix predicate on the "github_access_token" field.
func GithubAccessTokenHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenIsNil applies the IsNil predicate on the "github_access_token" field.
func GithubAccessTokenIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGithubAccessToken)))
	})
}

// GithubAccessTokenNotNil applies the NotNil predicate on the "github_access_token" field.
func GithubAccessTokenNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGithubAccessToken)))
	})
}

// GithubAccessTokenEqualFold applies the EqualFold predicate on the "github_access_token" field.
func GithubAccessTokenEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGithubAccessToken), v))
	})
}

// GithubAccessTokenContainsFold applies the ContainsFold predicate on the "github_access_token" field.
func GithubAccessTokenContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGithubAccessToken), v))
	})
}

// GitlabUserIDEQ applies the EQ predicate on the "gitlab_user_id" field.
func GitlabUserIDEQ(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDNEQ applies the NEQ predicate on the "gitlab_user_id" field.
func GitlabUserIDNEQ(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDIn applies the In predicate on the "gitlab_user_id" field.
func GitlabUserIDIn(vs ...int) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGitlabUserID), v...))
	})
}

// GitlabUserIDNotIn applies the NotIn predicate on the "gitlab_user_id" field.
func GitlabUserIDNotIn(vs ...int) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGitlabUserID), v...))
	})
}

// GitlabUserIDGT applies the GT predicate on the "gitlab_user_id" field.
func GitlabUserIDGT(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDGTE applies the GTE predicate on the "gitlab_user_id" field.
func GitlabUserIDGTE(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDLT applies the LT predicate on the "gitlab_user_id" field.
func GitlabUserIDLT(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDLTE applies the LTE predicate on the "gitlab_user_id" field.
func GitlabUserIDLTE(v int) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGitlabUserID), v))
	})
}

// GitlabUserIDIsNil applies the IsNil predicate on the "gitlab_user_id" field.
func GitlabUserIDIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGitlabUserID)))
	})
}

// GitlabUserIDNotNil applies the NotNil predicate on the "gitlab_user_id" field.
func GitlabUserIDNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGitlabUserID)))
	})
}

// GitlabAccessTokenEQ applies the EQ predicate on the "gitlab_access_token" field.
func GitlabAccessTokenEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenNEQ applies the NEQ predicate on the "gitlab_access_token" field.
func GitlabAccessTokenNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenIn applies the In predicate on the "gitlab_access_token" field.
func GitlabAccessTokenIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGitlabAccessToken), v...))
	})
}

// GitlabAccessTokenNotIn applies the NotIn predicate on the "gitlab_access_token" field.
func GitlabAccessTokenNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGitlabAccessToken), v...))
	})
}

// GitlabAccessTokenGT applies the GT predicate on the "gitlab_access_token" field.
func GitlabAccessTokenGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenGTE applies the GTE predicate on the "gitlab_access_token" field.
func GitlabAccessTokenGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenLT applies the LT predicate on the "gitlab_access_token" field.
func GitlabAccessTokenLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenLTE applies the LTE predicate on the "gitlab_access_token" field.
func GitlabAccessTokenLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenContains applies the Contains predicate on the "gitlab_access_token" field.
func GitlabAccessTokenContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenHasPrefix applies the HasPrefix predicate on the "gitlab_access_token" field.
func GitlabAccessTokenHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenHasSuffix applies the HasSuffix predicate on the "gitlab_access_token" field.
func GitlabAccessTokenHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenIsNil applies the IsNil predicate on the "gitlab_access_token" field.
func GitlabAccessTokenIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGitlabAccessToken)))
	})
}

// GitlabAccessTokenNotNil applies the NotNil predicate on the "gitlab_access_token" field.
func GitlabAccessTokenNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGitlabAccessToken)))
	})
}

// GitlabAccessTokenEqualFold applies the EqualFold predicate on the "gitlab_access_token" field.
func GitlabAccessTokenEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabAccessTokenContainsFold applies the ContainsFold predicate on the "gitlab_access_token" field.
func GitlabAccessTokenContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGitlabAccessToken), v))
	})
}

// GitlabRefreshTokenEQ applies the EQ predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenNEQ applies the NEQ predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenIn applies the In predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGitlabRefreshToken), v...))
	})
}

// GitlabRefreshTokenNotIn applies the NotIn predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGitlabRefreshToken), v...))
	})
}

// GitlabRefreshTokenGT applies the GT predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenGTE applies the GTE predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenLT applies the LT predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenLTE applies the LTE predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenContains applies the Contains predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenHasPrefix applies the HasPrefix predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenHasSuffix applies the HasSuffix predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenIsNil applies the IsNil predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGitlabRefreshToken)))
	})
}

// GitlabRefreshTokenNotNil applies the NotNil predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGitlabRefreshToken)))
	})
}

// GitlabRefreshTokenEqualFold applies the EqualFold predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabRefreshTokenContainsFold applies the ContainsFold predicate on the "gitlab_refresh_token" field.
func GitlabRefreshTokenContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGitlabRefreshToken), v))
	})
}

// GitlabAccessTokenExpiresAtEQ applies the EQ predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtNEQ applies the NEQ predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtIn applies the In predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGitlabAccessTokenExpiresAt), v...))
	})
}

// GitlabAccessTokenExpiresAtNotIn applies the NotIn predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGitlabAccessTokenExpiresAt), v...))
	})
}

// GitlabAccessTokenExpiresAtGT applies the GT predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtGTE applies the GTE predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtLT applies the LT predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtLTE applies the LTE predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGitlabAccessTokenExpiresAt), v))
	})
}

// GitlabAccessTokenExpiresAtIsNil applies the IsNil predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtIsNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGitlabAccessTokenExpiresAt)))
	})
}

// GitlabAccessTokenExpiresAtNotNil applies the NotNil predicate on the "gitlab_access_token_expires_at" field.
func GitlabAccessTokenExpiresAtNotNil() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGitlabAccessTokenExpiresAt)))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// HasTokens applies the HasEdge predicate on the "tokens" edge.
func HasTokens() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TokensTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TokensTable, TokensColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTokensWith applies the HasEdge predicate on the "tokens" edge with a given conditions (other predicates).
func HasTokensWith(preds ...predicate.Token) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TokensInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TokensTable, TokensColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSubmissions applies the HasEdge predicate on the "submissions" edge.
func HasSubmissions() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubmissionsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, SubmissionsTable, SubmissionsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSubmissionsWith applies the HasEdge predicate on the "submissions" edge with a given conditions (other predicates).
func HasSubmissionsWith(preds ...predicate.Submission) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubmissionsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, SubmissionsTable, SubmissionsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSubscription applies the HasEdge predicate on the "subscription" edge.
func HasSubscription() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubscriptionTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, SubscriptionTable, SubscriptionColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSubscriptionWith applies the HasEdge predicate on the "subscription" edge with a given conditions (other predicates).
func HasSubscriptionWith(preds ...predicate.Subscription) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubscriptionInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, SubscriptionTable, SubscriptionColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		p(s.Not())
	})
}
